//==============================================================================
// CDFJChess by Andrew Davie
// demo Chessboard Display
// derived from  Collect3 ARM routines by Darrell Spice, Jr.
//==============================================================================



//==============================================================================
// Includes
//--------------------------------------
//  defines_cdfj.h
//      defines and functions for CDFJ coprocessor
//  defines_from_dasm_for_c.h
//      auto-generated by the make file, it contains values from the 6507 code
//  defines.h
//      defines to make the code easier to read
//==============================================================================

#include <stdbool.h>

#include "defines_cdfj.h"
#include "defines_from_dasm_for_c.h"
#include "defines.h"

#include "main.h"
#include "bitpatterns.h"

#include "characterset.h"
#include "logo.h"
#include "attribute.h"
#include "bitshapes.h"
#include "drawplayer.h"
#include "overlay.h"
#include "drawscreen.h"
#include "cavedata.h"
#include "sound.h"
#include "movePlayer.h"
#include "drawBitmap.h"
#include "charRuntime.h"
#include "drawplanet.h"

#define DIGIT_SIZE 18           /* displayed lines */
#define DIGIT_SIZE_ROLLER 24        /* stored lines - rolling with spaces! */


#define DIGIT_DOGE   (11 * DIGIT_SIZE_ROLLER)
#define DIGIT_TIME      (12 * DIGIT_SIZE_ROLLER)
#define DIGIT_SPACE     (13 * DIGIT_SIZE_ROLLER)
#define DIGIT_LIVES     (14 * DIGIT_SIZE_ROLLER)
#define DIGIT_CAVE      (15 * DIGIT_SIZE_ROLLER)
#define DIGIT_LEVEL     (16 * DIGIT_SIZE_ROLLER)
#define DIGIT_DOGE_L    (17 * DIGIT_SIZE_ROLLER)

#define FLASH_DEAD 0x4F


////////////////////////////////////////////////////////////////////////////////
// CONFIGURABLE UX

//#define IDLE_TIME          500     /* cycle time in game-over state between Overview/Normal display */
#define SPARKLE            100     /* # frames to sparkle BG on extra life */
//#define EXPAND_SPEED         6     /* Amoeba expansion rate larger = faster, expansion speed for amoeba (/128)) */
#define ROLL_SPEED           3     /* score digit rolling. Factor of DIGIT_SIZE_ROLLER only (1/2/3/4/6/8/12) */
#define SCOREVISIBLETIME   130     /* # frames to show changed scoreline item before reverting to defaults */
#define DEAD_RESTART        20     /* # frames to hold trigger after loss of life, to start next life */

#define MAX_PEBBLES        100     /* # random pebbles to put in dirt */

    // Delays on RESET and SELECT are to allow non-ambiguous press of SELECT+RESET for suicide

#define RESET_DELAY         20     /* # frames to hold RESET before it is detected */
#define SELECT_DELAY        10     /* # frames to hold SELECT before it is detected */

////////////////////////////////////////////////////////////////////////////////



int parallax;

int drillHeight;

int scoreLineCurrent[10];
int scoreLineNew[10];
int water, lava;
unsigned char *lastWater;

const unsigned char *bgPalette;

#define SPACESHIPS 0
int spaceshipY[SPACESHIPS];
int spaceshipAccel[SPACESHIPS];
int spaceshipWait[SPACESHIPS];
int spaceshipMode[SPACESHIPS];
int spaceshipX[SPACESHIPS];
int spaceshipTargetX[SPACESHIPS];
int spaceshipVar[SPACESHIPS];
unsigned const char *spaceShipShape[SPACESHIPS];

int tuneIndex;
int millingTime;                // negative = expired


int scoreCycle;

int doge;
int time;
int level;
int terminalDelay;

bool dripFree;
bool lastDripFree;

extern int caveFlags;

#if ENABLE_SHAKE
int shakeX, shakeY;
int shakeTime;
#endif

#if ENABLE_PARALLAX
#define CHAR_SIZE (PIECE_DEPTH)

unsigned char parallaxBlank[CHAR_SIZE];
unsigned char charDust3[CHAR_SIZE];
unsigned char charDrip[CHAR_SIZE];
unsigned char charDrip1[CHAR_SIZE];
unsigned char charDrip2[CHAR_SIZE];
unsigned char charDrip3[CHAR_SIZE];
unsigned char charDripX[CHAR_SIZE];


unsigned char spaceToggle[40];
unsigned char spaceToggleDisplayed[40];

#endif


bool thisFrame[2][40];

int boardWidth;
int boardHeight;
int planetGravity;

void setAnimation(int animID);



struct Animation AnimIdx[TYPE_MAX];

//unsigned char AnimIdx[TYPE_MAX];


//==============================================================================
// Variables
//--------------------------------------
// Within C there are rules about where a variable can be seen based on where it
// is defined.  This is known as scope:
//      https://www.tutorialspoint.com/cprogramming/c_scope_rules.htm
//
// Very brief summary of scope:
//
//  Global Variable - variables defined outside of a function can be used by ANY function.
//  Local Variable - variables defined inside a function can be use by ONLY that function.
//
// The ARM used in the Harmony/Melody does not support floating point values, so
// we can only use data types of char and int. These types can be modified with
// unsigned and/or short to change the range of values that can be represented.
//
// signed char        =  8 bit, 1 byte,  range is           -128 to           127
// char               =  8 bit, 1 byte,  range is              0 to           255
// unsigned char      =  8 bit, 1 byte,  range is              0 to           255
// short int          = 16 bit, 2 bytes, range is        -32,768 to        32,767
// unsigned short int = 16 bit, 2 bytes, range is              0 to        65,535
// int                = 32 bit, 4 bytes, range is -2,147,483,648 to 2,147,483,647
// unsigned int       = 32 bit, 4 bytes, range is              0 to 4,294,967,295
//
// NOTE: variables of int and unsigned int result in smaller/faster code, but
// are not always practical to use due to limited amount of RAM available.
//
// When referencing data defined in the 6507 code:
//      BYTE = char (range -128 to 127)
//      BYTE = unsigned char (range 0 to 255)
//      WORD = short int (range -32768 to 32767)
//      WORD = unsigned short int (range 0 to 65535)
//
// NOTE: WORD data that will be used by the ARM must be on 2 byte boundaries.
//
//==============================================================================


// enum FLAG {
//     FLAG_THISFRAME = 0x80,
// };



unsigned char is_7800;  // 0 = 2600, non-zero = 7800

// Image Data

//const unsigned char *arena_increments =(unsigned char *)_ARENA_INCREMENTS;

unsigned char mm_tv_type = 0;  // 0 = NTSC, 1 = PAL, 2 = SECAM

enum Direction rockfordDirection = RIGHT;

int frameAdjustX;
int frameAdjustY;
int frameAdjustSmallX;
int frameAdjustSmallY;

bool amoebaAudio;
bool exitTrigger;
int diamondGrabTime;


// Timers

int flashTime;                  // frames for initial HOLD on BG colour flashing

int idleTimer;

unsigned int sparkleTimer;

// Scoring

int actualScore;
int partialScore;
int forceScoreDraw;

bool exitMode;

unsigned char ScorePtr[6];

unsigned int frameCounter;
unsigned int frameToggler;
unsigned int gameSpeed;
unsigned int toggler;

unsigned char displayMode, lastDisplayMode;

//unsigned char joy0FireBuffer = 0xFF;
unsigned int triggerPressCounter = 0;
unsigned int dogeCollected;

//#define PUSH_DELAY 10
//#define DELAY_AFTER_PUSH 3
unsigned int pushCounter;
unsigned int halt;


// unsigned int uncoverCount;
int rockfordX, rockfordY;
bool rockfordDead;
int lives;

int selectResetDelay;;
int resetDelay = 0;
int selectDelay = 0;

int diamondValue;
int extraDogeCoinValue;

int amoebaCounter = 0;
int amoebaGrew = 1;
int lastAmoebaGrew = 0;
int cave = 0;
bool caveCompleted;
unsigned char bufferedSWCHA = 0xFF;

unsigned int maxScrollXSpeed;


// COMPILE-TIME REVERSE BITS IN BYTE
#define RVS(a) ( \
      ((((a) >> 0) & 1) << 7) \
    | ((((a) >> 1) & 1) << 6) \
    | ((((a) >> 2) & 1) << 5) \
    | ((((a) >> 3) & 1) << 4) \
    | ((((a) >> 4) & 1) << 3) \
    | ((((a) >> 5) & 1) << 2) \
    | ((((a) >> 6) & 1) << 1) \
    | ((((a) >> 7) & 1) << 0) \
    )

#define P0(a) RVS(a)
#define P1(a) P0(a), P0(a+1)
#define P2(a) P1(a), P1(a+2)
#define P3(a) P2(a), P2(a+4)
#define P4(a) P3(a), P3(a+8)
#define P5(a) P4(a), P4(a+16)
#define P6(a) P5(a), P5(a+32)
#define P7(a) P6(a), P6(a+64)
#define P8(a) P7(a), P7(a+128)

// Want to call RVS(n) for 0-255 values. The weird #defines above aloow a single-call
// It's effectively a recursive power-of-two call of the base RVS macro

const unsigned char BitRev[] = {
    P8(0),
};


int scrollX;                // 16.16 PF pixels
int scrollY;                // 16.16 TRI pixel lines



int scrollSpeed = 0, scrollYSpeed = 0;
int targetScrollSpeed = 0, targetYScrollSpeed = 0;




//==============================================================================
// Contstants
//--------------------------------------
// Contstants do not change their value at runtime, so are stored in ROM.
//
// WARNING: If the const is left off the values will be stored in ROM, but then
// copied into RAM when the Harmony/Melody is turned on.
//==============================================================================


const unsigned char NTSCtoPAL[16] =
{
    // SeaGtGruff's conversion values from this post at AtariAge:
    // https://atariage.com/forums/topic/165424-modify-colour-palette/?do=findComment&comment=2043124
    0x00, 0x20, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0,
    0xd0, 0xb0, 0x90, 0x70, 0x50, 0x30, 0x30, 0x20
};

const unsigned char NTSCtoSECAM[16] =
{
    0x0e,   // 0 = white            e = white
    0x0c,   // 1 = yellow           c = yellow
    0x0c,   // 2 = yellowish orange c = yellow
    0x04,   // 3 = reddish orange   4 = red
    0x04,   // 4 = red              4 = red
    0x06,   // 5 = reddish purple   6 = purple
    0x06,   // 6 = purple           6 = purple
    0x06,   // 7 = bluish purple    6 = purple
    0x02,   // 8 = blue             2 = blue
    0x02,   // 9 = blue             2 = blue
    0x0a,   // a = bluish cyan      a = cyan
    0x0a,   // b = cyan             a = cyan
    0x08,   // c = green            8 = green
    0x08,   // d = green            8 = green
    0x08,   // e = olive green      8 = green
    0x0c    // f = brown            c = yellow
};

enum DIR {
    DIR_UP = 1,
    DIR_DOWN = 2,
    DIR_LEFT = 4,
    DIR_RIGHT = 8,
};

const int xInc[] = {

        // RLDU
    0,  // 0000
    0,  // 0001
    0,  // 0010
    0,  // 0011
    -1, // 0100
    -1, // 0101
    -1, // 0110
    0,  // 0111
    1,  // 1000
    1,  // 1001
    1,  // 1010
    0,  // 1011
    0,  // 1100
    0,  // 1101
    0,  // 1110
    0,  // 1111
};

const int yInc[] = {

        // RLDU
    0,  // 0000
    -1, // 0001
    1,  // 0010
    0,  // 0011
    0,  // 0100
    -1, // 0101
    1,  // 0110
    0,  // 0111
    0,  // 1000
    -1, // 1001
    1,  // 1010
    0,  // 1011
    0,  // 1100
    0,  // 1101
    0,  // 1110
    0,  // 1111
};


// Function Prototypes

unsigned char ColourConvert(unsigned char);
void GameOverscan();
void GameVerticalBlank();
void InitGameBuffers();
void Initialize();
void drawScreen();
//void SplashOverScan();
//void SplashVerticalBlank();
void Scheduler();
void SetupBoard();

extern void DecodeCave(const unsigned char *cave);
extern bool DecodeExplicitData();

void drawOverviewScreen();
unsigned int getRandom32();

extern int RandSeed1, RandSeed2;
extern void NextRandom(int *RandSeed1, int *RandSeed2);




//==============================================================================
// Function Definitions
//--------------------------------------
// main() is the initial function called when running C code. Main is defined as
// returning an int value. You could change it to void and it will still work;
// however, it will introduce compile time warnings, and unlike using void for
// other functions using void for main() will not save any ROM.
//==============================================================================




unsigned int buf[12];
const unsigned int bufferBase[2] = {
        VIDBUF_PF0_LEFT, VIDBUF_PF0_RIGHT
};


void clearBuffer(int buff) {
    for (int i = 0; i < _ARENA_SCANLINES; i++)
        *(RAM + buf[buff] + i) = 0;
}


#define defBuf(n) \
    buf[n] = mem; \
    mem += _ARENA_SCANLINES;


void setVideoBufferPointers() {

    unsigned int mem = _BOARD + boardWidth * boardHeight;

    defBuf(VIDBUF_COLUPF);
    defBuf(VIDBUF_COLUBK);
    defBuf(VIDBUF_GRP0A);
    defBuf(VIDBUF_GRP1A);
    defBuf(VIDBUF_COLUP0);
    defBuf(VIDBUF_COLUP1);

    defBuf(VIDBUF_PF0_LEFT);
    defBuf(VIDBUF_PF1_LEFT);
    defBuf(VIDBUF_PF2_LEFT);
    defBuf(VIDBUF_PF0_RIGHT);
    defBuf(VIDBUF_PF1_RIGHT);
    defBuf(VIDBUF_PF2_RIGHT);

    clearBuffer(VIDBUF_GRP0A);
    clearBuffer(VIDBUF_GRP1A);
    clearBuffer(VIDBUF_COLUPF);
    clearBuffer(VIDBUF_COLUBK);
}


void setFlash(int colour, int time) {
    ARENA_COLOR = colour;
    flashTime = time;
}


unsigned char ColourConvert(unsigned char color) {

    if (mm_tv_type == PAL) {
        return NTSCtoPAL[color>>4] +    // convert chroma value
               (color & 0x0f);          // retain luma value
    }

    else if (mm_tv_type == SECAM) {
        return color < 2 ? 0 : NTSCtoSECAM[color>>4];
    }

    else
        return color;
}



enum SCHEDULE {
    SCHEDULE_START,
    SCHEDULE_PROCESSBOARD,
    SCHEDULE_UNPACK_CAVE,
};

enum SCHEDULE gameSchedule = SCHEDULE_START;

const int cnoNext[] = { 1, 2, 0 };


int main() {

    // main() is called when the 6507 code writes to CALLFN.
    // The 6507 code sets the value of RUN_FUNC.
    
    switch (RUN_FUNC)
    {
    case _FN_INIT:
        Initialize();
        break;

    case _FN_GAME_OS:
        GameOverscan();
        break;

    case _FN_GAME_VB:
        GameVerticalBlank();
        break;

    case _FN_GAME_IDLE:
        Scheduler();
        break;
    }
    
    return 0;
}




void addScore(int score) {

    actualScore += score;
    scoreCycle = 1;
    forceScoreDraw = SCOREVISIBLETIME;

    partialScore += score;
    while (partialScore >= 500) {
        partialScore -= 500;
        if (lives < 9) {

            lives++;
            sparkleTimer = SPARKLE;
            scoreCycle = 1;
            AddAudio(SFX_EXTRA);
        }
    }
}

#if ENABLE_OVERLAY
const unsigned char (*overlayWord)[5];
#endif

void resetTracking() {

    // Set scroll track

    scrollX =(rockfordX - (HALFWAYX>>2)) << 16;
    scrollY = ((rockfordY - 4) * TRILINES) << 16;

    scrollSpeed = 0;
    targetScrollSpeed = 0;
    scrollYSpeed = 0;
    targetYScrollSpeed = 0;
}



void setColours() {

    unsigned char i;
    unsigned char colour[3];

    for (i = 0; i < 3; i++)
        colour[i] = ColourConvert(caveList[cave].caveColour[i]);

    unsigned char scorecol = lives? 0x29 : 0x49;
    unsigned char bgCol = flashTime ? ARENA_COLOR : 0;

    i = 0;
    if (displayMode == DISPLAY_NORMAL)
        while (i < SCORE_SCANLINES) {
            RAM[buf[VIDBUF_COLUPF] + i] = ColourConvert(scorecol);
            RAM[buf[VIDBUF_COLUBK] + i] = bgCol;
            
            scorecol -= (i + (i>>1))>>4;
            i++;
        }

    unsigned char cno = 0;
    while (i < _ARENA_SCANLINES) {
        RAM[buf[VIDBUF_COLUPF] + i] = ColourConvert(colour[cno]);
        RAM[buf[VIDBUF_COLUBK] + i] = bgCol;
        cno = cnoNext[cno];
        i++;
    }


}


void InitGameX() {

    for (int i = 0; i < 2; i++)
        thisFrame[0][i] = thisFrame[1][i] = false;

    for (int sno = 0; sno < SPACESHIPS; sno++) {
        spaceshipY[sno] = -((120 + (getRandom32() & 0x20)) <<16); //16 << 16;
        spaceshipAccel[sno] = 0;
        spaceshipWait[sno] = 0;
        spaceshipMode[sno] = 0;
        spaceshipVar[sno] = 0;
        spaceshipX[sno] = 5 << 14; //(((getRandom32() & 0xFF) >> 8) * 160) << 14;
        spaceshipTargetX[sno] = 5 << 16;

        if (true || getRandom32() & 1)
            spaceShipShape[sno] = &eroShip[0];
        else
            spaceShipShape[sno] = &rocketShip[0];


    }

    drillHeight = 1;
//    displayMode = DISPLAY_PLANET;


#if ENABLE_PARALLAX

    for (int i = 0; i < boardWidth; i++) {
        spaceToggle[i] = 99;
        spaceToggleDisplayed[i] = 99;
    }

    // setup RAM chars to contain correct overview-mode char defs
    for (int i = 0; i < CHAR_SIZE; i++) {
        parallaxBlank[i] = 0;
    }

#endif





    dripFree = true;
    water = 0;
    lava = 0;
    lastWater = 0;

#if ENABLE_SHAKE
    shakeTime = 0;
    shakeX = 0;
    shakeY = 0;
#endif

extern int looneyIndex;
extern int looneyY;

    looneyIndex = 0;
    looneyY = 0x400;

extern int radius;
extern int rinc;

    radius = 0;
    rinc = 100;

    rockfordX = 2;
    rockfordY = 4;

    playerX = (rockfordX * 4) << 16;
    playerY = (rockfordY * PIECE_DEPTH/3) << 16;

    playerSpeedX = 20000;
    playerSpeedY = 30000;


    exitTrigger = false;
    exitMode = false;
    idleTimer = 0;
    terminalDelay = 0;

    tuneIndex = -1;
    amoebaAudio = false;
    gameSchedule = SCHEDULE_START;

//rockfordX = 20; //tmp
//rockfordY = 10; //tmp

    
    KillRepeatingAudio();

    pushCounter = 0;
    halt = 0;
    sparkleTimer = 0;

    amoebaGrew = 1;
    lastDisplayMode = DISPLAY_NONE;


    bufferedSWCHA = 0xFF;

//    joy0FireBuffer = 0xFF;

    dogeCollected = 0;

    scrollSpeed = 0;
    scrollYSpeed = 0;
    rockfordDead = false;

    gameSpeed = GAMESPEED * DEBUG_SLOWDOWN; //12;
    frameCounter = gameSpeed;               // force initial 

    setFlash(0,0);



    scrollX = 2 << 14; //((((getRandom32() & 0xFF) * 38) >> 8) + 1) << 16;
    scrollY = 2 << 16; //((((getRandom32() & 0xFF) * 20) >> 8) + 1) << 16;


    InitAudio();
    AddAudio(SFX_TICK);


#if ENABLE_OVERLAY

    if (overlayWord != overlayBoulderDash) {
        overlayWord = overlayBoulderDash;

        fSpeed = 0x120;
        fIndex = 0;
        rotateOffset = 0;
    }

#endif

    frameAdjustX = frameAdjustY = 0;
    frameAdjustSmallX = frameAdjustSmallY = 0;
    rockfordDirection = 1;

    bgPalette = caveList[cave].caveBGColour;

    DecodeCave(caveList[cave].cavePtr);

    displayMode = caveFlags & DEF_PLANET ? DISPLAY_PLANET : DISPLAY_NORMAL;
    setVideoBufferPointers();



    gameSchedule = SCHEDULE_UNPACK_CAVE;


    forceScoreDraw = SCOREVISIBLETIME;

    for (int i = 0; i < TYPE_MAX; i++) {
        AnimIdx[i].index = -2;
        AnimIdx[i].count = 0;
    }

//    AnimIdx[TYPE_BOULDER_SHAKE].count = -1;



    playerAnimationID = -1;
    setAnimation(ID_BLANK);

    caveCompleted = false;

    selectResetDelay = 0;
    scoreCycle = 2;

    for (int i = 0; i < 10; i++)
        scoreLineCurrent[i] = -1;
}



void Initialize() {
    
    // during Initialize() SWCHA contains the results of the 6507 routine which
    // detects if the console is a 2600 or 7800.
    is_7800 = SWCHA;    // 0 = 2600, non-zero = 7800
        
    // When the Harmon/y Melody is powered up the 4K of Display Data RAM will
    // contain random values, so we should zero it out to have a known starting
    // point. Using myMemsetInt is faster than using myMemset, but requires
    // dividing the number of bytes by 4 because an integer is stored in 4 bytes.

    for (int i = 0; i < 4096/4; i++)
        RAM_INT[i] = 0;

    //myMemsetInt(RAM_INT, 0, 4096/4);
    
    // likewise the datastream increments will be random, so set them to 1.0
    for(int i = 0; i <= 34; i++)
        setIncrement(i, 1, 0);


    actualScore = 0;
    partialScore = 0;

    cave = 0;
    lives = 3;
    level = 0;

    selectResetDelay = 0;
    
    InitAudio();
    InitGameX();

    InitGameBuffers();
}






void GameScheduleDrawSprites();
#if ENABLE_OVERLAY
void GameScheduleDrawOverlay();
#endif
void GameScheduleAnimate();
void GameScheduleProcessBoardRow();


void setChar(int x, int y, int ch) {

    unsigned char *p = RAM + _BOARD + y * boardWidth + x;
    *p = ch;
}



void formLandscape(){
 return;

    int horizon = (((getRandom32() & 0xFF) * 4) >> 8) + 8;
    for (int i = 1; i < boardWidth-1; i++) {

        int offset = (((getRandom32() & 0xFF) * 3) >> 8) - 1;
        horizon += offset;

        if (horizon < 5) 
            horizon = 5;

        if (horizon > 20)
            horizon = 20;


        for (int j = 1; j < horizon; j++)
            setChar(i,j, CH_BLANK_SKY);


    }

}


void Scheduler() {

    switch (gameSchedule) {
    case SCHEDULE_UNPACK_CAVE:
        if (DecodeExplicitData()) {
            // add pebbles




            if (caveFlags & DEF_PEBBLE)
                for (int pebble = 0; pebble < MAX_PEBBLES; pebble++) {
                    int rnd = getRandom32();
                    int idx = _BOARD + (((rnd & 0xFFFF) * boardWidth * boardHeight) >> 16);
                    if (RAM[idx] == CH_DIRT)
                        RAM[idx] = CH_RUBBLE + (rnd & 1);
                }

            if (lava) {
                AddAudio(SFX_LAVA);
            }


    if (caveFlags & DEF_PLANET) {

//         for (int y = 0; y < boardHeight; y++) {
//   //          for (int x = 0; x < 30; x+= 30) {
//                 //*(RAM + _BOARD + y * boardWidth + x + 20) = CH_SHADOW; //*(RAM + _BOARD + y * boardWidth + x);
//                 *(RAM + _BOARD + y * boardWidth) = CH_STEEL;
//     //        }
//         }

            // for (int x = -3; x < 3; x++) {
            //     //*(RAM + _BOARD + y * boardWidth + x + 20) = CH_SHADOW; //*(RAM + _BOARD + y * boardWidth + x);
            //     *(RAM + _BOARD + boardHeight * boardWidth / 2 + x + 10) = CH_STEEL;
            // }


        // for (int y = 0; y < boardHeight; y++) {
        //     for (int x = 0; x < 10; x++) {
        //         *(RAM + _BOARD + y * boardWidth + x + 10) = CH_SHADOW; //*(RAM + _BOARD + y * boardWidth + x);
        //     }
        // }



        for (int y = 0; y < boardHeight; y++) {
            for (int x = 0; x < 10; x++) {
                *(RAM + _BOARD + y * boardWidth + x + 30) = *(RAM + _BOARD + y * boardWidth + x);
            }
        }
    }


            formLandscape();





            gameSchedule = SCHEDULE_START;
        }
        break;
    case SCHEDULE_START:
        SetupBoard();
        break;
    case SCHEDULE_PROCESSBOARD:
        GameScheduleProcessBoardRow();
        break;
    default:
        break;
    }
}


void InitGameDatastreams() {


    // initialize the Data Streams for the Arena
    setPointer(_DS_PF0_LEFT, buf[VIDBUF_PF0_LEFT]);
    setPointer(_DS_PF1_LEFT, buf[VIDBUF_PF1_LEFT]);
    setPointer(_DS_PF2_LEFT, buf[VIDBUF_PF2_LEFT]);
    setPointer(_DS_PF0_RIGHT, buf[VIDBUF_PF0_RIGHT]);
    setPointer(_DS_PF1_RIGHT, buf[VIDBUF_PF1_RIGHT]);
    setPointer(_DS_PF2_RIGHT, buf[VIDBUF_PF2_RIGHT]);

    setPointer(_DS_AUDV0, _BUF_AUDV);
    setPointer(_DS_AUDC0, _BUF_AUDC);
    setPointer(_DS_AUDF0, _BUF_AUDF);

    setPointer(_DS_COLUPF, buf[VIDBUF_COLUPF]);
    setPointer(_DS_COLUBK, buf[VIDBUF_COLUBK]);
    setPointer(_DS_COLUP0, buf[VIDBUF_COLUP0]);
    setPointer(_DS_COLUP1, buf[VIDBUF_COLUP1]);

    setPointer(_DS_GRP0a, buf[VIDBUF_GRP0A]);
    setPointer(_DS_GRP1a, buf[VIDBUF_GRP1A]);

    // initialize the Jump Data Stream
    setPointer(0x21, _BUF_JUMP1);
}


//==============================================================================
// Game routines
//--------------------------------------
//  All game logic runs in OverScan
//  All prep of the datastreams runs in Vertical Blank
//==============================================================================




void GameOverscan() {

    Scroll();
    parallax = (caveFlags & DEF_PARALLAX) && (~SWCHB & 0b10000000);


#if ENABLE_SHAKE
    if (shakeTime) {

        int rnd = getRandom32();
        int shakeMagnitude = shakeTime > 4 ? 4: shakeTime;
        int shk = ((rnd & 0xFF) * shakeMagnitude) >> 8;

        shakeX = ((((rnd & 0xFF0000) * shk) >> 24) - (shk >> 1)) << 13;
        rnd = getRandom32();
        shakeY = ((((rnd & 0xFF0000) * shk) >> 22) - (shk >> 1)) << 13;

        if (!--shakeTime) {
            shakeX = 0;
            shakeY = 0;

        }
        else
            if (playerAnimationID == ID_STAND && shakeTime > 50) //rnd < 0x01000000)
               setAnimation(ID_SHAKE);
    }
#endif

    InitGameDatastreams();
    playAudio();
    GameScheduleAnimate();
        
    if ((SWCHA != 0xFF) && frameCounter >= 4)
        bufferedSWCHA = SWCHA;


    // int rnd = getRandom32();

    if ((getRandom32() & 0x1ff) < 10) {

        if (lava > 1) {
            lava--;
#if ENABLE_SHAKE
            shakeTime += 20;
#endif
        }

        if (water > 1)
            water--;
    }

    if (lastAmoebaGrew && millingTime)
        millingTime--;


    if (exitMode) {
        if (!time) {
            if (!--terminalDelay)
                caveCompleted = true;
        }
        else {

            terminalDelay = 100;

            time -= 256;            
            if (time < 0)
                time = 0;

            addScore(level+1);
        }
    }


    if (gameSchedule != SCHEDULE_UNPACK_CAVE) {

        if (GAME_RESET_PRESSED && GAME_SELECT_PRESSED)
            selectResetDelay++;

        else {

            selectResetDelay = 0;

            if (!GAME_RESET_PRESSED)
                resetDelay = 0;

            else if (++resetDelay == RESET_DELAY) {

#if ENABLE_OVERLAY
                overlayWord = 0;
#endif

                Initialize();
                InitGameX();
                AddAudio(SFX_BLIP);
                return;
            }

            if (!GAME_SELECT_PRESSED)
                selectDelay = 0;

            // (DEBUG) "next level" SELECT press
            else if (++selectDelay == SELECT_DELAY) {
                AddAudio(SFX_BLIP);
                lives = 3;
                caveCompleted = true;
            }

            if (caveCompleted) {

                if (++cave >= caveCount) {
                    if (level < 4)
                        ++level;
                    cave = 0;
                }

                InitGameX();
                return;
            }

        }
    }

    if (JOY0_FIRE) {
        triggerPressCounter++;

        // Long-press after death will restart
        if (rockfordDead && lives && triggerPressCounter == DEAD_RESTART) {
            AddAudio(SFX_BLIP);
            InitGameX();
            return;
        }
    }
    else {

        if (triggerPressCounter && triggerPressCounter < DEAD_RESTART) {
            displayMode ^= (DISPLAY_NORMAL ^ DISPLAY_OVERVIEW);
            AddAudio(SFX_BLIP);
        }

        triggerPressCounter = 0;
    }

    GameScheduleDrawSprites();

    if (flashTime > 0)
        flashTime--;

    if (!flashTime && ARENA_COLOR) {
        int intensity = ARENA_COLOR & 0x0F;
        if (intensity) {
            if (intensity == 0x0F)
                ARENA_COLOR = (ARENA_COLOR & 0xF0) | 0x07;
            flashTime = 4;
            ARENA_COLOR--;
        }
        else
            flashTime = ARENA_COLOR = 0;
    }        

}


void clear(unsigned char *p, unsigned char v, int len) {
    for (int i=0; i < len; i++)
        *p++ = v;        
}

#define DIGIT_GAP \
        ________   \
        ________   \
        ________   \
        ________   \
        ________   \
        ________  



static unsigned char digitShape[] = {

        _X___X__  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        _X___X__  

        DIGIT_GAP

        __X___X_
        __X___X_
        __X___X_
        _XX__XX_  
        _XX__XX_  
        _XX__XX_  
        _XX__XX_  
        __X___X_
        __X___X_
        __X___X_
        __X___X_
        __X___X_
        __X___X_
        __X___X_
        __X___X_
        __X___X_
        __X___X_
        __X___X_

        DIGIT_GAP

        _X___X__  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        X_X_X_X_  
        __X___X_
        __X___X_
        __X___X_
        _XX__XX_  
        XXX_XXX_  
        XXX_XXX_  
        XX__XX__  
        X___X___  
        X_X_X_X_  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  

        DIGIT_GAP

        _X___X__  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        X_X_X_X_  
        __X___X_
        __X___X_
        _XX__XX_  
        _X___X__  
        _XX__XX_  
        _XX__XX_  
        __X___X_
        __X___X_
        X_X_X_X_  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        _X___X__  

        DIGIT_GAP

        X___X___  
        X___X___  
        X___X___  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        __X___X_
        __X___X_
        __X___X_
        __X___X_
        __X___X_

        DIGIT_GAP

        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        X_X_X_X_  
        X___X___  
        XX__XX__  
        XXX_XXX_  
        XXX_XXX_  
        _XX__XX_  
        __X___X_
        __X___X_
        __X___X_
        X_X_X_X_  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        _X___X__  

        DIGIT_GAP

        _X___X__  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        X_X_X_X_  
        X___X___  
        XX__XX__  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        _X___X__  

        DIGIT_GAP

        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        X_X_X_X_  
        __X___X_
        __X___X_
        __X___X_
        __X___X_
        _XX__XX_  
        _X___X__  
        _X___X__  
        _X___X__  
        _X___X__  
        _X___X__  
        _X___X__  
        _X___X__  
        _X___X__  

        DIGIT_GAP

        _X___X__  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        XXX_XXX_  
        XXX_XXX_  
        _X___X__  
        XXX_XXX_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        _X___X__  

        DIGIT_GAP

        _X___X__  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        _XX__XX_  
        __X___X_
        X_X_X_X_  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        _X___X__  

        DIGIT_GAP

    // repeat 0

        _X___X__  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        X_X_X_X_  
        XXX_XXX_  
        XXX_XXX_  
        XXX_XXX_  
        _X___X__  

        DIGIT_GAP

    // repeat 0

        XX__XX__  
        XX__XX__  
        ________  
        XXX_XXX_  
        XXX_XXX_  
        ________  
        X_X_X_X_  
        X_X_X_X_  
        ________  
        X_X_X_X_  
        X_X_X_X_  
        ________  
        XXX_XXX_  
        XXX_XXX_  
        ________  
        XX__XX__  
        XX__XX__  
        ________  

        DIGIT_GAP

        XXX_XXX_  
        XXX_XXX_  
        ________  
        XXX_XXX_  
        XXX_XXX_  
        ________  
        _X___X__  
        _X___X__  
        ________  
        _X___X__  
        _X___X__  
        ________  
        _X___X__  
        _X___X__  
        ________  
        _X___X__  
        _X___X__  
        ________  

        DIGIT_GAP

        ________  
        ________  
        ________  
        ________  
        ________  
        ________  
        ________  
        ________  
        ________  
        ________  
        ________  
        ________  
        ________  
        ________  
        ________  
        ________  
        ________  
        ________  

        DIGIT_GAP

        _X___X__  
        _X___X__  
        _X___X__  
        ________  
        XXX_XXX_  
        XXX_XXX_  
        ________  
        _X___X__  
        _X___X__  
        ________  
        _X___X__  
        _X___X__  
        X_X_X_X_  
        X_X_X_X_  
        ________  
        X_X_X_X_  
        X_X_X_X_  
        ________  
  
        DIGIT_GAP

        XX__XX__  
        XX__XX__  
        ________  
        XXX_XXX_  
        XXX_XXX_  
        ________  
        X_X_X_X_  
        X_X_X_X_  
        ________  
        XX__XX__  
        XX__XX__  
        ________  
        X___X___  
        X___X___  
        ________  
        X___X___  
        X___X___  
        ________  

        DIGIT_GAP

        X___X___  
        X___X___  
        ________  
        X___X___  
        X___X___  
        ________  
        X___X___  
        X___X___  
        ________  
        X___X___  
        X___X___  
        ________  
        XXX_XXX_  
        XXX_XXX_  
        ________  
        XXX_XXX_  
        XXX_XXX_  
        ________  

        DIGIT_GAP

        ___X___X
        ___X___X
        ________  
        ___X___X
        ___X___X
        ________  
        ________  
        ________  
        ________  
        ________  
        ________  
        ________  
        ___X___X
        ___X___X
        ________  
        ___X___X
        ___X___X
        ________  

        DIGIT_GAP

};


const int pwr[] = {
    1,10,100,1000,10000,100000,
};


// right-to-left, least-significant first digit position
const unsigned char mask[] = {
    0xF0, 0x0F, 0x0F, 0xF0, 0xF0,
    0xF0, 0x0F, 0x0F, 0xF0, 0xF0,
};

const bool mirror[] = {
    1,1,0,0,1,
    1,1,0,0,1,
};

const unsigned char pfOffset[] = {
    VIDBUF_PF2_RIGHT,VIDBUF_PF2_RIGHT,VIDBUF_PF1_RIGHT,VIDBUF_PF1_RIGHT,VIDBUF_PF0_RIGHT,
    VIDBUF_PF2_LEFT,VIDBUF_PF2_LEFT,VIDBUF_PF1_LEFT,VIDBUF_PF1_LEFT,VIDBUF_PF0_LEFT,
};

void drawBigDigit(int offset, int pos) {

    for (int line = 0; line < DIGIT_SIZE; line++, offset++) {
        int base = buf[pfOffset[pos]] + line;
        *(RAM + base) = (*(RAM + base) & ~mask[pos])
            | ((mirror[pos]? BitRev[digitShape[offset]] : digitShape[offset]) & mask[pos]);
    }
}


void drawDecimal(int cvt, int pos) {

    int forced = 0;
    int digitPos = 0;
    for (int digit = 2; digit >= 0; digit--) {

        int displayDigit = 0;
        while (cvt >= pwr[digit]) {
            displayDigit += DIGIT_SIZE_ROLLER;
            cvt -= pwr[digit];
        }

        forced |= displayDigit;

        if (forced || !digit)
            scoreLineNew[pos-digitPos++] = displayDigit;
    }
}



static inline void drawDogeCoinAndTime(){

    scoreLineNew[9] = DIGIT_DOGE_L;
    scoreLineNew[8] = DIGIT_DOGE;

    drawDecimal(doge, 7);


    static int pulseCount = 0;
    if (!exitMode && time < 0xA00 && (pulseCount++ & 8)) {
        return;
    }

    scoreLineNew[4] = DIGIT_TIME;    
    drawDecimal(time>>8, 3);
}



static inline void drawLives() {

    scoreLineNew[8] = DIGIT_LIVES;
    drawDecimal(lives, 7);
    scoreLineNew[5] = DIGIT_LEVEL;
    drawDecimal(level + 1, 4);
    scoreLineNew[2] = DIGIT_CAVE;
    drawDecimal(cave + 1, 1);

}



static inline void drawTheScore() {

    // Decimal convert...

    int cvtScore = actualScore;
    for (int digit = 5; digit >= 0; digit--) {

        int displayDigit = 0;
        while (cvtScore >= pwr[digit]) {
            displayDigit += DIGIT_SIZE_ROLLER;
            cvtScore -= pwr[digit];
        }

        if (ScorePtr[digit] != displayDigit) {
            ScorePtr[digit] += ROLL_SPEED;
            if (ScorePtr[digit] >= DIGIT_SIZE_ROLLER*10)
                ScorePtr[digit] = 0;
        }

        scoreLineNew[digit+2] = ScorePtr[digit];
    }

}


void drawScore() {

    static int lockScore = 0;
    static int displayedScoreCycle = -1;

    if (lockScore > 0)
        lockScore--;
    else {
        if (displayedScoreCycle != scoreCycle) {
            displayedScoreCycle = scoreCycle;
            lockScore = 40;
        }
    }

    for (int i = 0; i < 10; i++)
        scoreLineNew[i] = DIGIT_SPACE;

    switch (displayedScoreCycle) {
    case 0:
        drawDogeCoinAndTime();
        break;
    case 1:
        drawTheScore();
        break;
    case 2:
        drawLives();
        break;
    }

    // draw all changed digits
    for (int i = 0; i < 10; i++) {
        //if (scoreLineNew[i] != scoreLineCurrent[i]) { //TMP??
            scoreLineCurrent[i] = scoreLineNew[i];
            drawBigDigit(scoreLineCurrent[i], i);
        //}
    }

    if (forceScoreDraw) {
        forceScoreDraw--;
        if (!forceScoreDraw) {
            forceScoreDraw = SCOREVISIBLETIME;
            if (rockfordDead)
                scoreCycle = cnoNext[scoreCycle];
            else
                scoreCycle = 0;
        }
    }

}



void GameVerticalBlank() {
 
    frameCounter++;
    frameToggler++;

    if (time && /*!uncoverCount &&*/ !rockfordDead) {

        time--;
        if ((time & 0xFF) == 0xFF) {

            time -= 0xC4;           // magic!  - (-256+60)
            if (time < 0xA00) {
                scoreCycle = 0;
                forceScoreDraw = SCOREVISIBLETIME;
                AddAudio(SFX_COUNTDOWN2);
            }
        }
    }



    if (gameSchedule != SCHEDULE_UNPACK_CAVE) {




//        GameScheduleAnimate();
#if ENABLE_OVERLAY
        GameScheduleDrawOverlay();
#endif

        looneyTuneFade();
    }
}



void setPalette(int start, int size, int step, int tweak) {

    setColours();

    int bgCharLine = (scrollY >> 16) * 3;
    int absLine = 0;
    int pfCharLine = 0;
    
    if (start) {
        absLine = bgCharLine;
        bgCharLine--;

        while (bgCharLine >= size) {
            bgCharLine -= size;
            pfCharLine++;
        }
    }

    int lavaLine = lava - tweak - PIECE_DEPTH;
    int waterLine = water - tweak - PIECE_DEPTH;
#if ENABLE_SHAKE
    lavaLine += (shakeY >> 16);
    waterLine += (shakeY >> 16);
#endif    


    int i = start;
    while (i < _ARENA_SCANLINES) {

        if (lava && absLine >= lavaLine) {

            unsigned char lavaCol = 0x44;
            int delta = (absLine - lavaLine);

            if (delta < 14) {
                lavaCol = 0x2E - (delta >> 2);
            } else {

                lavaCol = 0x4A - (delta >> 3);
                if (lavaCol < 0x44)
                    lavaCol = 0x44;
            }

            //if (!flashTime) {
                RAM[buf[VIDBUF_COLUBK] + i ] = 
                RAM[buf[VIDBUF_COLUBK] + i + 1 ] =
                RAM[buf[VIDBUF_COLUBK] + i + 2] = ColourConvert(lavaCol);
            //}

            RAM[buf[VIDBUF_COLUPF] + i] = ColourConvert(0x48);
            RAM[buf[VIDBUF_COLUPF] + i + 1 ] = ColourConvert(0x28);
            RAM[buf[VIDBUF_COLUPF] + i + 2 ] = ColourConvert(0x3c);

        }
        
        else if (water && absLine >= waterLine) {

            unsigned char waterCol = 0x90;
            int delta = absLine - waterLine;
            if (delta < 32) {
                waterCol += (32 - delta) >> 2;
            }


            //if (!flashTime) {

                RAM[buf[VIDBUF_COLUBK] + i ] = ColourConvert(waterCol);
                RAM[buf[VIDBUF_COLUBK] + i + 1 ] = ColourConvert(waterCol);
                RAM[buf[VIDBUF_COLUBK] + i + 2 ] = ColourConvert(waterCol);

            //}

            RAM[buf[VIDBUF_COLUPF] + i ] = ColourConvert(0xA4);
            RAM[buf[VIDBUF_COLUPF] + i + 1] = ColourConvert(0x84);     // boulder body
            RAM[buf[VIDBUF_COLUPF] + i + 2] = ColourConvert(0x94);     // flow + inside stream colour

        }

        else
            RAM[buf[VIDBUF_COLUPF] + i] = ColourConvert(bgPalette[pfCharLine]);
        
            
        bgCharLine += 3;            
        if (bgCharLine >= size) {
            bgCharLine = 0;
            pfCharLine++;
        }


        absLine += step;
        i += 3;
    }

}






void drawSoftwareSprites() {



    for (int sno = 0; sno < SPACESHIPS; sno++) {    

//        if (spaceshipVar[sno] > 0)
//            spaceshipVar[sno]--;


        int animBalls = spaceshipWait[sno] ? 4 : 1;
        animBalls = (frameToggler >> animBalls);

            drawBitmap(&shipFuelTank[0],
                (spaceshipX[sno] + (3<<14)) & 0xFFFFC000,
                    
//                    ((spaceshipVar[sno] << 16) & 0xFFFF0000) * 3
                    + (90 << 16)
                    - ((  ((animBalls + 2) & 3) * 3) << 16)
                    + (spaceshipY[sno] & 0xFFFF0000) * 3, 

                true);
            
            drawBitmap(spaceShipShape[sno],
                (spaceshipX[sno] & 0xFFFFC000),
                (((35 << 16) + spaceshipY[sno]) & 0xFFFF0000)  * 3,
                true);
            
            drawBitmap(&flagUSA[0],
                (spaceshipX[sno] & 0xFFFFC000),
                (((20 << 16) + spaceshipY[sno]) & 0xFFFF0000) * 3,
                true);

            drawBitmap(&shipFuelTank[0],
                ((spaceshipX[sno] & 0xFFFFC000) - (4<<14)) & 0xFFFFC000,
                //(spaceshipVar[sno] << 16) * 3 +
                 + (90 << 16)
                 - (((animBalls & 3) * 3) << 16)
                 + (spaceshipY[sno] & 0xFFFF0000) * 3,
                 true);


            if (!(spaceshipMode[sno] == 1 && spaceshipWait[sno]) && (getRandom32() & 3))
                drawBitmap(&rocketShipFlame[0],
                    (spaceshipX[sno] & 0xFFFFC000),
                    (((35 << 16) + spaceshipY[sno]) & 0xFFFF0000) * 3,
                    true);


        if (spaceshipMode[sno] == 0) {

        if (!spaceshipWait[sno]) {

            if (spaceshipVar[sno] < 20)
                spaceshipVar[sno] +=2;


            if (spaceshipX[sno] < spaceshipTargetX[sno])
                spaceshipX[sno] += 0x01000;
            if (spaceshipX[sno] > spaceshipTargetX[sno])
                spaceshipX[sno] -= 0x01000;
        }


            spaceshipAccel[sno] += 0x400;

            if (spaceshipY[sno] >= (24<<16) * 3 - 0x8000) {
                spaceshipAccel[sno] = 0;
                spaceshipY[sno] = (24 << 16) * 3; // + (getRandom32() & 0x0F0000);
                spaceshipWait[sno] = 10 + (getRandom32() & 0x1F) * 10;
                spaceshipMode[sno]++;
                    spaceshipTargetX[sno] = ((((getRandom32() & 0xFF) * 160) >> 8)) << 14;
#if ENABLE_SHAKE
//                    shakeTime += 10;
#endif
            }
#if ENABLE_SHAKE
            else

            {
//                shakeTime += 10;
            }
#endif                
        }

        if (spaceshipMode[sno] == 1) {

            if (spaceshipWait[sno])
                // spaceshipY[sno] -= 0x100;
                spaceshipWait[sno]--;
               else {
#if ENABLE_SHAKE
                    // shakeTime += 120;
#endif
                    spaceshipAccel[sno] -= 0x200;


                    if (spaceshipY[sno] < (10 << 16)*3) {
                        spaceshipMode[sno] = 0;
                    }

               }
        }

        spaceshipY[sno] += spaceshipAccel[sno];



    }




}

void clearVideoBuffer() {
    unsigned char *p = RAM + buf[VIDBUF_PF0_LEFT];
    for (int i = 0; i < 6 * _ARENA_SCANLINES; i++)
        *p++ = 0;         
}


void GameScheduleDrawSprites() {

    if (gameSchedule == SCHEDULE_UNPACK_CAVE)
        return;

    if (sparkleTimer)
        sparkleTimer--;

    if (exitMode)
        displayMode = DISPLAY_NORMAL;


    switch (displayMode) {
    case DISPLAY_OVERVIEW:

        if (lastDisplayMode != displayMode) {
         
            clearVideoBuffer();
            removeSprite();


        }

        setPalette(0, 9, PIECE_DEPTH/3, 6);
        drawOverviewScreen();
        drawPlayerSmallSprite();
        drawSoftwareSprites();
        break;

    case DISPLAY_NORMAL:

        if (lastDisplayMode != displayMode) {

            // clear lines below score to cleanup overview/normal garbage

            for (int i = DIGIT_SIZE; i < SCORE_SCANLINES; i++)
                for (int pf = VIDBUF_PF0_LEFT; pf <= VIDBUF_PF2_RIGHT; pf++)
                    *(RAM + buf[pf] + i) = 0;

            removeSmallSprite();
            resetTracking();


            for (int i = 0; i < 10; i++)
                scoreLineCurrent[i] = -1;
        }

        setPalette(SCORE_SCANLINES, PIECE_DEPTH, 3, 3);
        drawScore();
        drawScreen();
        drawSoftwareSprites();

        doPlayer();


        drawPlayerSprite();

        break;

    case DISPLAY_PLANET: {

            setPalette(0, PIECE_DEPTH, 3, 3);
            drawPlanet();

        }
        break;

    default:
        break;

    }


    lastDisplayMode = displayMode;

}



#if ENABLE_OVERLAY
void GameScheduleDrawOverlay() {


    // Handle "GAME OVER" display 
    // ... if the square doesn't contain rockford

//    int what = RAM[_BOARD + rockfordY * 40 + rockfordX] & (0x7F|0x80);
//    char type = CharToType[what];

    if (rockfordDead && !flashTime) {

        if (!lives) {

            if (overlayWord != overlayGameOver) {

                overlayWord = overlayGameOver;
                fIndex = 0;
                rotateOffset = 0;
                fSpeed = 0x120;
            }

            if (JOY0_FIRE) { 

                if (fSpeed < 0)
                    rotateOffset = 0;

                if (fSpeed < 0x400)
                    fSpeed += 28;

                idleTimer = 0;

            }

            else {

                if (idleTimer++ > IDLE_TIME) {

                    displayMode ^= 1;
                    idleTimer = 0;
                    if (fSpeed < 0)
                        rotateOffset = 0;

                    if (fSpeed < 0x400)
                        fSpeed += 250;
                }
            }
        }

#if ENABLE_TOGGLE_DISPLAY_ON_DEATH

        else {

            // loss of a life -- switch display occasionally

            if (idleTimer++ > IDLE_TIME) {
                displayMode ^= 1;
                idleTimer = 0;
            }

        }
#endif

    }



   Overlay(overlayWord);
}
#endif


unsigned char boardRow;
unsigned char boardCol;

int changeAmoebaToBoulder;

void SetupBoard() {

    if (frameCounter > gameSpeed) {

        lastDripFree = dripFree;
        dripFree = true;

        frameCounter = 0;
        toggler++;

        boardCol = -1;
        boardRow = 0;

        changeAmoebaToBoulder = amoebaCounter;
        amoebaCounter = 0;

        lastAmoebaGrew = amoebaGrew;
        amoebaGrew = 0;

#if ENABLE_PARALLAX
        for (int i = 0; i < boardWidth; i++) {
            spaceToggleDisplayed[i] = spaceToggle[i];
            spaceToggle[i] = 99;
        }
#endif

        gameSchedule = SCHEDULE_PROCESSBOARD;

    }
}


void GameScheduleAnimate() {

    // animate!
    // count == -1 -> inactive
    

    for (int type = 0; type < TYPE_MAX; type++) {
        if (Animate[type]) {

            if (!AnimIdx[type].count || AnimIdx[type].index < 0) {

                int idx = AnimIdx[type].index + 2;
                
                bool redo;
                do {

                    redo = false;

                    switch ((*Animate[type])[idx]) {
                    case 255:     
                        idx = 0;
                        redo = true;
                        break;
                    case 254:                   // play sound
                        AddAudio((*Animate[type])[++idx]);
                        ++idx;
                        redo = true;
                        break;
                    }
                } while (redo);


                AnimIdx[type].index = idx;

                if (!AnimIdx[type].count)
                    AnimIdx[type].count = (*Animate[type])[idx + 1];        //TODO
    
            }

            if (AnimIdx[type].count > 0 && AnimIdx[type].count < 255)
                AnimIdx[type].count--;
        }
    }

}



void InitGameBuffers() {
    
    // set the Jump Datastream so each entry runs the NORMAL KERNEL by default
    // init Jump Datastream
    for (int i=0; i < _ARENA_SCANLINES - 1; i++)
        RAM_SINT[(_BUF_JUMP1 / 2) + i] = _NORMAL_KERNEL;
    RAM_SINT[ _BUF_JUMP1_EXIT / 2 ] = _EXIT_KERNEL;
}








void Explode(unsigned char *where, unsigned char explosionShape) {

    typedef struct {
        signed char x;
        signed char y;
    } OFFSET;

    static const OFFSET offset[] = {
        { 0,-2, },
        { -1,-1, },
        { 0,-1, },
        { 1,-1, },
        { -2,0, },
        { -1,0, },
        { 1,0, },
        { 2,0, },
        { -1,1, },
        { -0,1, },
        { 1,1, },
        { 0,2, },
    };


#if ENABLE_SHAKE
    shakeTime += 130;
#endif

//    KillAudio(SFX_SHAKE);
    AddAudio(SFX_EXPLODE);

    // explosionShape |= FLAG_THISFRAME;

    for (int i = 0; i < 12; i++) {
        unsigned char *cell = where + offset[i].y * boardWidth + offset[i].x;
        int attribute = Attribute[CharToType[*cell]];
        if (attribute & ATT_EXPLODABLE)
            *cell = explosionShape;
    }

    *where = explosionShape;
}


// //00 = facing left
// //01 = facing up
// //10 = facing right
// //11 = facing down

// // turn right = -1
// // turn left = +1

// int move[] = {
//     -1, -40, +1, +40,
// };




#if 0
void moveRockford(unsigned char *this, unsigned char blanker) {


    static const unsigned char direct[] = {
        DIR_UP,
        DIR_DOWN,
        DIR_LEFT,
        DIR_RIGHT,
    };

    static const int offsetD[] = {
        -40,
        +40,
        -1,
        +1,
    };

    static const int faceDirection[] = {
        0,
        0,
        LEFT,
        RIGHT,
    };

    static const int newAnim[] = {
        ID_WALK_VERT,
        ID_WALK_VERT_DOWN,
        ID_WALK,
        ID_WALK,
    };

    static const char newSnatch[] = {
        ID_SNATCH_UP,
        ID_SNATCH_DOWN,
        ID_SNATCH,
        ID_SNATCH,
    };


    if (exitMode)
        return;


#define DIRT_DIRT 0x80
#define DIRT_DOGE 0x40

    unsigned char dirtFlag = 0;

// exitTrigger = true; //tmp

    for (int dir = 0; dir < 4; dir++ ) {

        int offset = offsetD[dir];

        if ((bufferedSWCHA & (direct[dir] << 4)) == 0) {       // direction button?

//                    setFlash(0x46,1);

            unsigned char destType = CharToType[*(this+offset) & (0x7F|0x80)];  // dubious masking of FLAG

            bufferedSWCHA = 0xFF; //|= (direct[dir] << 4);

            if (faceDirection[dir]) {
                if (rockfordDirection != faceDirection[dir]) {
                    pushCounter = 0;
                    rockfordDirection = faceDirection[dir];
                }
            }

            if (Attribute[destType] & (ATT_BLANK | ATT_PERMEABLE | ATT_GRAB | ATT_EXIT)) {
            
                pushCounter = 0;

                if (destType == TYPE_DIRT
                    ||destType == TYPE_DIRT2
                    ||destType == TYPE_DIRT3) {
                        AddAudio(SFX_DIRT);
                        dirtFlag = DIRT_DIRT;
                        //AnimIdx[TYPE_DUST] = 0;
                }

                if (destType == TYPE_BLANK)
                    AddAudio(SFX_SPACE);

                if (destType == TYPE_OUTBOX) {
                    exitMode = true;
                    setAnimation(ID_SHAKE); //? fail
                }

                if (Attribute[destType] & ATT_GRAB) {

                    addScore(doge? diamondValue: extraDogeCoinValue);

                    if (doge) {
                        if (!--doge) {
                            setFlash(0x0F, 4);     //open door
                            exitTrigger = true;
                            AddAudio(SFX_EXIT);
                        }
                    }


                    dogeCollected++;
                    diamondGrabTime = 10;
                    dirtFlag = DIRT_DOGE;

                    AddAudio(SFX_DOGE);
                }

                if (JOY0_FIRE) {

                    if (Attribute[destType] & (ATT_GRAB | ATT_PERMEABLE)
                        && !(Attribute[destType] & ATT_BLANK)) {  // snatch?
                        *(this+offset) = (
                               (destType == TYPE_DIRT)
                            || (destType == TYPE_DIRT2)
                            || (destType == TYPE_DIRT3)
                            ? CH_DUST : CH_DOGE_GRAB) ; // | FLAG_THISFRAME;
                        diamondGrabTime = 1;
                        setAnimation(newSnatch[dir]);
                    }
                    else
                    {
                        setAnimation(ID_JUMP);
                    }
                    
                }

                else {

                    rockfordX += xInc[direct[dir]];
                    rockfordY += yInc[direct[dir]];

                    frameAdjustX = frameAdjustY = 0;

                    *(this+offsetD[dir]) = CH_ROCKFORD ; // | FLAG_THISFRAME;
                    *this = (dirtFlag == DIRT_DIRT ? CH_DUST : blanker) ; // | FLAG_THISFRAME;

                    if (dirtFlag & DIRT_DIRT) {
                        AnimIdx[TYPE_ROCKFORD].index = -2;
                        AnimIdx[TYPE_ROCKFORD].count = 0;
                    }

                    if (dirtFlag & DIRT_DOGE) {
                        AnimIdx[TYPE_ROCKFORD].index = 6;
                        AnimIdx[TYPE_ROCKFORD].count = 0;
                    }

                    int anim = newAnim[dir];
                    //if (anim == ID_WALK && dirtFlag)
                    //    anim = ID_PUSHWALK;

                    setAnimation(anim);
                }


            } else {

                if (faceDirection[dir] && (Attribute[destType] & ATT_PUSH)) {

                    pushCounter++;

                    if (pushCounter > 1)
                        setAnimation(ID_PUSH);
                    else
                        setAnimation(ID_JUMP);


                    if (pushCounter > 20 || (pushCounter > 5 && (getRandom32() & 7) < 2)) { 
                        if (Attribute[CharToType[(*(this+ 2 * offset))&(0x7F|0x80) ]] & ATT_BLANK) {

                            halt = DELAY_AFTER_PUSH;
                            pushCounter = 0;

                            *(this + 2 * offset) = CH_BOULDER ; // | FLAG_THISFRAME;
                            if (JOY0_FIRE)
                                *(this+offset) = blanker ; // | FLAG_THISFRAME;
                            else {
                                rockfordX += offset;
                                *(this+offset) = CH_ROCKFORD ; // | FLAG_THISFRAME;
                                *this = blanker ; // | FLAG_THISFRAME;
                            }

                            AddAudio(SFX_PUSH);

                        }
                    }
                }

                else
                    setAnimation(ID_JUMP);
            }

            return;
        }
    }

    // no direction was detected...

    pushCounter = 0;

    if (*(this-40) == (CH_DOGE_FALLING ; // | FLAG_THISFRAME)
        || *(this-40) == (CH_BOULDER_FALLING ; // | FLAG_THISFRAME))
            setAnimation(ID_DIE);

    else {

        playerAnimationLoop = 0;                   // bypass any looping!

        static const unsigned char animID[] = {
            ID_BLINK,       200, 
            ID_WIPE_HAIR,   20,
            ID_IMPATIENT,   12, 
            ID_TURN,        17, 
            ID_LOOK,        30, 
            ID_SHADES,      25, 
            ID_ARMSCROSSED, 13,
        };

        // choose an idle animation

        unsigned int rnd = getRandom32();
        if (playerAnimationID == ID_STAND && (rnd & 0xFF) < 0x60) {
            rnd = getRandom32();
            int idle = ((rnd & 0xFF * 7) >> 8) << 1; 
            rnd = getRandom32();
            if ((rnd & 0x3FF) < animID[idle + 1])
                setAnimation(animID[idle]);
                
        }
    }

}
#endif


void fixRock(unsigned char *rock) {


    unsigned char linkage = CH_ROCK0;

    if (CharToType[*(rock+1)] == TYPE_ROCK)
        linkage += 1;
    if (CharToType[*(rock+boardWidth)] == TYPE_ROCK)
        linkage += 2;
    if (CharToType[*(rock-1)] == TYPE_ROCK)
        linkage += 4;
    if (CharToType[*(rock-boardWidth)] == TYPE_ROCK)
        linkage += 8;

    *rock = linkage;
}


void doRoll(unsigned char *this, unsigned int creature) {

    if (boardRow > 20)
        return;

    unsigned char _DOWN = CharToType[*(this + boardWidth)];
    unsigned char *LEFTWARDS = this - 1;
    unsigned char *RIGHTWARDS = this + 1;

    //unsigned char c = creature == CH_DOGE ? CH_DOGE : CH_ROCK0;


#if ENABLE_SHAKE
    if (Attribute[_DOWN] & ATT_ROLL
        || (shakeTime && (getRandom32() & 0xFF) < 10)) {
#else
    if (Attribute[_DOWN] & ATT_ROLL) {
#endif

        if (boardCol > 0 && (Attribute[CharToType[*LEFTWARDS]] & ATT_ROCKFORDYBLANK)) {

            unsigned char lowerLeft = (*(LEFTWARDS + boardWidth));
            unsigned char typeLL = CharToType[lowerLeft];
            unsigned char typeL = CharToType[*LEFTWARDS];

            if (CharToType[creature] == TYPE_ROCK
                && ((typeLL == TYPE_ROCKFORD && (Attribute[typeL] & ATT_BLANK))
                || (typeL == TYPE_ROCKFORD && (Attribute[typeLL] & ATT_BLANK))))
                    *this = CH_BOULDER_SHAKE;

            else if (Attribute[typeL] & Attribute[typeLL] & ATT_BLANK) {
//                KillAudio(SFX_SHAKE);
                AddAudio(SFX_PUSH);    
                *LEFTWARDS = CH_BOULDER_FALLING; // | FLAG_THISFRAME;
                *this = CH_BLANK ; // | FLAG_THISFRAME;
                thisFrame[1][boardCol-1] = true;
                return;
            }
        }
        
        if (boardCol < boardWidth - 1
            && (Attribute[CharToType[*RIGHTWARDS]] & ATT_ROCKFORDYBLANK)) {

            unsigned char lowerRight = (*(RIGHTWARDS + boardWidth));
            unsigned char typeLR = CharToType[lowerRight];
            unsigned char typeR = CharToType[*RIGHTWARDS];

            if (CharToType[creature] == TYPE_ROCK &&
                ((typeLR == TYPE_ROCKFORD && (Attribute[typeR] & ATT_BLANK))
                || (typeR == TYPE_ROCKFORD && (Attribute[typeLR] & ATT_BLANK)))
                )
                    *this = CH_BOULDER_SHAKE;

            else if (Attribute[typeR] & Attribute[typeLR]  & ATT_BLANK) {

//                KillAudio(SFX_SHAKE);
                AddAudio(SFX_PUSH);    

                *RIGHTWARDS = CH_BOULDER_FALLING; // | FLAG_THISFRAME;
                *this = CH_BLANK ; // | FLAG_THISFRAME;
                thisFrame[0][boardCol+1] = true;

                return;
            }
        }

        if (creature == CH_BOULDER_SHAKE)
            *this = CH_ROCK0;

    }

    //else if (creature == CH_BOULDER_SHAKE)
    //    *this = CH_BOULDER;

}


//const int dirX[] = { -1, 1, -40, 40, -41, 41, -39, 39 };

const int dirX[] = { -1,  1,  0,  0, -1, 1,  1, -1 };
const int dirY[] = {  0,  0, -1,  1, -1, 1, -1,  1 };


void GameScheduleProcessBoardRow() {

//    if (!uncoverCount)
    for (int block = 0; block < 80; block++) {

        boardCol++;
        if (boardCol >= boardWidth) {
            boardCol = 0;
            boardRow++;


            for (int i = 0; i < boardWidth; i++) {
                thisFrame[0][i] = thisFrame[1][i];
                thisFrame[1][i] = false;
            }


            if (boardRow > 21) {

                gameSchedule = SCHEDULE_START;

                bool oldDead = rockfordDead;

                //int what = RAM[_BOARD + rockfordY * boardWidth + rockfordX];
                //int type = CharToType[what];
//tmp                rockfordDead = (type != TYPE_ROCKFORD && type != TYPE_ROCKFORD_PRE);

                if (oldDead != rockfordDead) {
                    setFlash(FLASH_DEAD, 2);
                    setAnimation(ID_SKELETON);

                    forceScoreDraw = SCOREVISIBLETIME;
                    lives--;


                    KillAudio(SFX_TICK);            // no heartbeat
                    KillAudio(SFX_DEADBEAT2);
                    AddAudio(SFX_DEADBEAT);

                }

/*                if (rockfordDead) {

                    int dir = (bufferedSWCHA >> 4) ^ 0b1111;
                    
                    rockfordX += xInc[dir];
                    if (rockfordX < 1)
                        rockfordX = 1;
                    if (rockfordY > 39)
                        rockfordY = 39;
                                        
                    rockfordY += yInc[dir];
                    if (rockfordY < 1)
                        rockfordY = 1;
                    if (rockfordY > 21)
                        rockfordY = 21;

                    bufferedSWCHA = 0xFF;

                }
*/
                return;
            }
        }


        if (thisFrame[0][boardCol])
            break;


        unsigned char *this = &RAM[_BOARD + (boardRow * boardWidth) + boardCol];

        if (CharToType[*this] == TYPE_DIRT
         || CharToType[*this] == TYPE_RUBBLE || CharToType[*this] == TYPE_RUBBLE1) {

#if ENABLE_PARALLAX
            if (spaceToggle[boardCol] > boardRow)
                spaceToggle[boardCol] = boardRow;
#endif
            roundDirtCorner(this);
        }
        
        
        



        unsigned char creature = *this;
        //unsigned char *prev = this - boardWidth;


        unsigned char blanker = CH_BLANK;
        if (water && boardRow * PIECE_DEPTH > water)
            blanker = CH_WATER;
        if (lava && boardRow * PIECE_DEPTH > lava)
            blanker = CH_LAVA;


        if (water && boardRow * 21 + 6  > water && boardRow > 2 && boardRow < 21 && (Attribute[CharToType[creature]] & ATT_WATER)) {
            *this = (CH_WATER + (getRandom32() & 3)) ; // | FLAG_THISFRAME;
            thisFrame[1][boardCol] = true;
        }

        unsigned char cType = CharToType[creature];


#if ENABLE_SHAKE
        if (shakeTime && cType == TYPE_DIRT && ((getRandom32() & 0x1FF) < 20) )
            *this = CH_DUST;
#endif

        if (lava && (boardRow * 21 + 6 > lava) && cType != TYPE_LAVA) {

            if (cType
     //           && (Attribute[cType] & CH_LAVA)
                && (boardRow > 4 && boardRow < 21 && boardCol > 0 && boardCol < boardWidth - 1)
                && (getRandom32() & (0x7FF)) < 3) {
                Explode(this, CH_EXPLODETOBLANK0);
                setFlash(0x42, 4);
//                shakeTime += 100;
            }

            else if (Attribute[cType] & ATT_LAVA) {
                *this = CH_LAVA ; // | FLAG_THISFRAME;
//                thisFrame[1][boardCol] = true;
            }

/*            else if ((Attribute[cType] & ATT_LAVA)
                || ((getRandom32() & 0x1FF) < 3
                && boardRow > 4 && boardRow < 21 && boardCol > 0 && boardCol < 39))
                *this = CH_LAVA ; // | FLAG_THISFRAME;
                */
        }

 
        creature = *this;

        int deltaY = (signed int) boardRow - (signed int) rockfordY;
        if (deltaY < 0)
            deltaY = -deltaY;

        int deltaX = (signed int) boardCol - (signed int) rockfordX;
        if (deltaX < 0)
            deltaX = -deltaX;


        unsigned int doubler = 10;
//        if (boardCol == rockfordX)
//            doubler *= 4;

        if ((caveFlags & DEF_DRIP) &&  lastDripFree

            // && boardRow * 21 > (scrollY >> 16)
            // && boardRow * 21 < (scrollY >> 16) + _ARENA_SCANLINES - 20
            // && boardCol * 4 > (scrollX >> 16) + 4
            // && boardCol * 4 < (scrollX >> 16) + 36

           && (deltaX < 6 && deltaY < 5)
           && boardRow < boardHeight
           && (Attribute[CharToType[creature] & ATT_DRIP]) &&  *(this + boardWidth) == CH_BLANK
            //&& *(this+80) != CH_BLANK
            && (getRandom32() & 0xFF) < doubler
            )
            {

                *(this + boardWidth) = CH_DRIP; // ; // | FLAG_THISFRAME;
                thisFrame[1][boardCol] = true;

                AnimIdx[TYPE_DRIP].index = -2;
                AnimIdx[TYPE_DRIP].count = 0;

                dripFree = false;
                lastDripFree = false;

                //setFlash(0x44,10);
            }
            

        //if (!(creature & FLAG_THISFRAME)) {


        unsigned char type = CharToType[creature];        
        if (Attribute[type] & ATT_ACTIVE) {
            

            switch (type) {

            case TYPE_EGG: {


                    if (!(frameToggler & 7))
                        break;

                    if ((getRandom32() & 0xFF) < 10) {
                        *this = CH_EXPLODETOBLANK3;
                        break;
                    }

                    int dirtNeighbours = 0;
                    for (int i = 0; i < 8; i++)
                        if (CharToType[*(this + boardWidth * dirY[i] + dirX[i])] == TYPE_DIRT)
                            dirtNeighbours++;

                    if (!dirtNeighbours) {
                        *this = CH_EXPLODETOBLANK3;
                        break;
                    }

                    int crowded = 0;
                    for (int i = 0; i < 8; i++)
                        if (CharToType[*(this + boardWidth + dirY[i] + dirX[i])] == TYPE_EGG)
                            crowded++;

                    if (crowded > 2) {
                        *this = CH_EXPLODETOBLANK3;
                        break;
                    }


                    if ((getRandom32() & 0xFF) < 200) {

                        int moveTo = getRandom32() & 3;
                        int offset = boardWidth * dirY[moveTo] + dirX[moveTo];
                        if (CharToType[*(this + offset)] == TYPE_DIRT) {
                            *(this + offset) = CH_EGG;

                            switch (moveTo) {
                                case 1:
                                    thisFrame[0][boardCol+1] = true;
                                    break;
                                case 3:
                                    thisFrame[1][boardCol] = true;
                                    break;
                            }
                            break;
                        }
                    }
                }
            break;


            case TYPE_AMOEBA:
                {

                //     block+=2;

                //     // Trapped? Change to doge
                //     // if (!lastAmoebaGrew) {
                //     //     *this = CH_DOGE;
                //     //     break;
                //     // }

                //     // if (changeAmoebaToBoulder > MAXIMUM_AMOEBA_SIZE) {
                //     //     *this = CH_ROCK0;
                //     //     break;
                //     // }
                    
                    
                //     int rnd = getRandom32();

                //     amoebaCounter++;

                //     for (int i = 0; i < 8; i++) {

                //         unsigned char *where = this + boardWidth * dirY[i] + dirX[i];
                //         unsigned char newCh = (rnd & 3) + CH_AMOEBA0;

                //         if (Attribute[CharToType[*where]] & ATT_PERMEABLE) {
                //             amoebaGrew = 1;

                //             int expandSpeed = millingTime ? EXPAND_SPEED : EXPAND_SPEED * 4;

                //             if ((rnd & 0x1FF) < expandSpeed) {
                //                 //setFlash(0xB2,10);
                //                 *where = newCh ; // | FLAG_THISFRAME;
                //             }
                //         }

                //         // don't allow side-by-side sameness
                //         if (!(rnd & 0x700) && *this == *where)
                //             *this = newCh;


                //         rnd >>= 2;
                //     }
                }
                break;


            case TYPE_LAVA:
                {
                    int rnd = getRandom32();

                    for (int i = 0; i < 4; i++) {

                        unsigned char *where = this + boardWidth * dirY[i] + dirX[i];
                        unsigned char newCh = (rnd & 3) + CH_LAVA;

                        // don't allow side-by-side sameness
                        if (!(rnd & 0xF00) && *this == *where)
                            *this = newCh;

                        rnd >>= 2;
                    }
                }
                break;


            case TYPE_WATER: {

                // if ((toggler & 1) == 0) {

                    unsigned int rnd = getRandom32();
                    unsigned char *where = this-1;
                    unsigned char newCh = (rnd & 3) + CH_WATER;

                    // don't allow side-by-side sameness
                    if (!(rnd & 0x300) || *this == *where)
                        *this = newCh;

                    if (lastWater && CharToType[(*lastWater)] == TYPE_WATER)
                        *lastWater = *this;
                    lastWater = this;

                // }

            }
            break;


            case TYPE_ROCK:
                if (!thisFrame[0][boardCol])
                    fixRock(this);
                break;


            case TYPE_ROCKFORD:


                // pause if pushed bolder
                if (halt) {
                    bufferedSWCHA = 0xFF;
                    halt--;
                }

//                else
//                    moveRockford(this, blanker);

                bool die = false;


                if (lava && boardRow * 21 + 10 > lava)
                    die = true;


                if (selectResetDelay > DEAD_RESTART || (!time && !terminalDelay))
                    die = true;


                if (die) {
                    Explode(this, CH_EXPLODETOBLANK0);
                    setFlash(0x44, 4);
                    *this = CH_BLANK;
                }

                break;



            default:
                break;

            }


            unsigned char *next = this + boardWidth;

            switch (creature) {


            case CH_DRILLBODY: {

                    int drillDir = (((getRandom32() & 0xFF) * 3) >> 8) - 1;
                    if (drillDir) {

                        for (int i = 1; i <= drillHeight; i++) {
                            *(this + i * boardWidth) = CH_BLANK;
                        }

                        int newDrillHeight = drillHeight + drillDir;
                        if (newDrillHeight < 1)
                            newDrillHeight = 1;
                        if (newDrillHeight > 10)
                            newDrillHeight = 10;                     

                        unsigned char *dest = this + boardWidth * newDrillHeight;

                        if (Attribute[CharToType[*dest]] & ATT_EXPLODES) {

                            if ((getRandom32() & 0xFF) < 75) {
                                addScore(1234);
                                Explode(dest, CH_EXPLODETODOGE0);
                                drillHeight = newDrillHeight;
                            }
                            else {
                                //shakeTime += 60;

                                if (CharToType[*dest] == TYPE_BOULDER)
                                    *dest = CH_BOULDER_SHAKE;
                            }
                        }

                        else {
#if ENABLE_SHAKE
                            shakeTime = 0;
#endif
                            drillHeight = newDrillHeight;

                        }



                    }


                    for (int i = 1; i <= drillHeight; i++) {
                        *(this + i * boardWidth) = CH_DRILL;
                    }


                }
                break;


            // case CH_DIRTY:
            // case CH_DIRTY2:
            // case CH_DIRTY3:

            //     if (!(getRandom32() & (0x7F|0x80)F))
            //         *this = CH_DUST;
            //     break;




            case CH_DRIP:

//??                doge = CH_BLANK;

#define DRIP_END 14
#define DRIP_END2 24

                if (water && (boardRow * PIECE_DEPTH + PIECE_DEPTH >= water)) {
                    *this = CH_BLANK;
                    break;
                }



                if (AnimIdx[TYPE_DRIP].index == DRIP_END
                    || AnimIdx[TYPE_DRIP].index == DRIP_END2) {

                    if (!(Attribute[CharToType[*(this + boardWidth)]] & ATT_BLANK)) {
                        *this = CH_DRIPX;
                        AnimIdx[TYPE_DRIP_SPLASH].index = -2;
                        AnimIdx[TYPE_DRIP_SPLASH].count = 0;

                        if (CharToType[*(this + boardWidth)] == TYPE_ROCKFORD) {
                            setAnimation(ID_DRIP + (getRandom32() & 1));
                            AddAudio(SFX_DRIP);
                        }

                        dripFree = false;
                        lastDripFree = true;
                    }
                                                
                    else {                          
                        *this = CH_BLANK;
                        *(this + boardWidth) = CH_DRIP;
                        AnimIdx[TYPE_DRIP].index = DRIP_END + 2;
                        AnimIdx[TYPE_DRIP].count = 0;
                        dripFree = false;
                    }
                }
                else {
                    dripFree = false;
                    lastDripFree = false;
                }

                break;

            case CH_DRIPX:

                if (AnimIdx[TYPE_DRIP_SPLASH].count == 255) {
                    *this = CH_BLANK;
                }
//                    else
//                        dripFree = false;

                break;



            case CH_BOULDER_SHAKE:

                if ((getRandom32() & 0xFF) < 50) {
                    *this = CH_BOULDER_FALLING;
                }
                break;


            // DogeCoin explosions
            // Cycle through explosion frames (0-3) and then become a diamond

            case CH_EXPLODETODOGE0:
            case CH_EXPLODETODOGE1:
            case CH_EXPLODETODOGE2:
            case CH_EXPLODETODOGE3:
            case CH_EXPLODETOBLANK0:
            case CH_EXPLODETOBLANK1:
            case CH_EXPLODETOBLANK2:
            case CH_EXPLODETOBLANK3:
                *this = (creature + 1); // ; // | FLAG_THISFRAME;
                break;

            case CH_EXPLODETOBLANK4:
                *this = CH_BLANK ; // | FLAG_THISFRAME;
                break;

            case CH_EXPLODETODOGE4:
                *this = CH_DOGE;
                break;

//                    __attribute__  ((fallthrough));
/*
            case CH_DOGE:
            case CH_DOGE_PULSE_0:
            case CH_DOGE_PULSE_1:
            case CH_DOGE_PULSE_2:
            case CH_DOGE_PULSE_3:
            case CH_DOGE_PULSE_4:
            case CH_DOGE_PULSE_5:
            case CH_DOGE_PULSE_6:
            case CH_DOGE_PULSE_7:
            case CH_DOGE_PULSE_8:
            case CH_DOGE_PULSE_9:
*/
            case CH_ROCK1:
            case CH_ROCK2:
            case CH_ROCK3:
            case CH_ROCK4:
            case CH_ROCK5:
            case CH_ROCK6:
            case CH_ROCK7:
            case CH_ROCK8:
            case CH_ROCK9:
            case CH_ROCKA:
            case CH_ROCKB:
            case CH_ROCKC:
            case CH_ROCKD:
            case CH_ROCKE:
            case CH_ROCKF:

                if ((getRandom32() & 0x7FF) > 10)
                    break;

                __attribute__  ((fallthrough));

            case CH_ROCK0:

            {
                if (!planetGravity)
                    break;


                block += 1;
                unsigned char _DOWN = CharToType[*next];


                if (_DOWN == TYPE_ROCKFORD && CharToType[creature] == TYPE_ROCK) {
                    *this = CH_BOULDER_SHAKE;
                    break;
                }


                else if (CharToType[creature] == TYPE_ROCK
                    && Attribute[_DOWN] & (ATT_SEMIBLANK | ATT_BLANK)) {

                    if (CharToType[*(this-1)] == TYPE_ROCK 
                        || CharToType[*(this+1)] == TYPE_ROCK
                        || CharToType[*(this - boardWidth)] == TYPE_ROCK) {
                        // attached!
                        *this = CH_BOULDER_SHAKE;
                        break;
                    }



                    // if (creature == CH_BOULDER_SHAKE) {
                    //     creature = CH_ROCK0; //CH_BOULDER;
                    //     AnimIdx[TYPE_BOULDER_SHAKE].count = -1; // turn off
                    // }

                    *this = CH_BLANK ; // | FLAG_THISFRAME;
                    
                    if (CharToType[creature] == TYPE_DOGE)
                        *next = CH_DOGE;

                    else
                    {
                        *next = CH_BOULDER_FALLING;
                    }
                    
                    



                    
//                        *next = (creature + 2) ; // | FLAG_THISFRAME;       // falling, scanned this frame

                    int typeDown = CharToType[*(next + boardWidth)];
                    int att = Attribute[typeDown];
                    if (!(att & ATT_NOROCKNOISE)) {
                        if (att & ATT_HARD)
                            AddAudio(SFX_ROCK);
                        else
                            AddAudio(SFX_ROCK2);
                    }
                }

                else
                    doRoll(this, creature);
            }
            break;


            case CH_DOGE_FALLING:

                AddAudio(SFX_DOGE);

                __attribute__  ((fallthrough));

            case CH_BOULDER_FALLING: {

                unsigned char _DOWN = CharToType[*next];

                if (Attribute[_DOWN] & ATT_BLANK) {
                    
                    *this = blanker ; // | FLAG_THISFRAME;
                    *next = creature ; // | FLAG_THISFRAME; // falling scanned this frame

                    thisFrame[1][boardCol] = true;



                    _DOWN = CharToType[*(next + boardWidth)];
                    int att = Attribute[_DOWN];
                    if (_DOWN != TYPE_BOULDER_FALLING && !(att & ATT_NOROCKNOISE)) {
                        if (creature == CH_BOULDER_FALLING) {
                            if (att & ATT_HARD)
                                AddAudio(SFX_ROCK);
                            else
                                AddAudio(SFX_ROCK2);
                        }

                        if (!blanker && type == TYPE_BOULDER_FALLING) {

                            unsigned char *dL = this + boardWidth - 1;
                            unsigned char *dR = dL + 2;

                            if (!CharToType[*dR])
                                *dR = CH_DUST_RIGHT;

                            if (!CharToType[*dL])
                                *dL = CH_DUST_LEFT;
                        }
                    }
                }

                else if (Attribute[_DOWN] & (ATT_SQUASHABLE_TO_DOGES | ATT_SQUASHABLE_TO_BLANKS)) {

                    if (Attribute[_DOWN] & ATT_SQUASHABLE_TO_DOGES)
                        Explode(next, CH_EXPLODETODOGE0);
                
                    else if (Attribute[_DOWN] & ATT_SQUASHABLE_TO_BLANKS) {
                        
                        if (_DOWN != TYPE_DOGE && _DOWN != TYPE_EGG) {

                            Explode(next, CH_EXPLODETOBLANK0);

                            if (_DOWN == TYPE_ROCKFORD)
                                *next = CH_EXPLODETOBLANK1;

                        }
                        else {
                            *next = CH_EXPLODETOBLANK0;
                        }

                    }
                }


            
                else {
                    
                    // stop falling


                    if (CharToType[creature] == TYPE_DOGE)
                        *this = CH_DOGE;
                    else
                    {
                        *this = CH_ROCK0;
                    }
                    
                    fixRock(this);

//                        *this = creature - 2;  
                    doRoll(this, *this);    
                    // shakeTime += 1; //tmp


                }

                break;
            }

            case CH_DOORCLOSED:
                if (exitTrigger)
                    *this = CH_DOOROPEN_0;
                break;


            case CH_ROCKYa:



//tmp                    // rockfordX = boardCol * 4;
                // rockfordY = boardRow * PIECE_DEPTH;

                //diamondValue = scrollYSpeed;

                AnimIdx[type].index = -2; //TYPE_ROCKFORD_PRE] = 0;
                AnimIdx[type].count = 0; //TYPE_ROCKFORD_PRE] = 0;

                //if (scrollSpeed == 0 && scrollYSpeed == 0)
                    *this = CH_ROCKYb; //creature + 1;
                break;
//                    __attribute__  ((fallthrough));
            
            case CH_ROCKYb:

                *this = CH_ROCKYc;
                break;

            case CH_ROCKYc: {
                bool wait = scrollSpeed | scrollYSpeed;
                if (!wait)
                    *this = creature + 1;
            }
                break;

            case CH_ROCKYd:

#if ENABLE_OVERLAY
                if (fSpeed == -1) {
#endif
                    AddAudio(SFX_BIRTH);
                    setAnimation(ID_STARTUP);
                    *this = CH_ROCKFORD; // ; // | FLAG_THISFRAME;
#if ENABLE_OVERLAY
                }
#endif
                break;


            case CH_DOGE_GRAB:
            case CH_DIRT_GRAB:
                // Only works because there's only ever one grab
                if (!--diamondGrabTime)
                    *this = CH_BLANK;
                break;


            case CH_DUST:
            case CH_DUST2:
            case CH_DUST_LEFT:
            case CH_DUST_RIGHT:
            case CH_DUST2_RIGHT:
            case CH_DUST2_LEFT:

                if (frameCounter & 63) // || (getRandom32() & 0xFF) > 20)
                    break;

                *this = creature + 1;
                break;

            case CH_DUST3:
            case CH_DUST3_RIGHT:
            case CH_DUST3_LEFT:
                *this = CH_BLANK;
                break;


            default:
                break;
            }
        }
        //}

        // Clear any "scanned this frame" objects on the previous line
        // note: we need to also do the last row
        // if (boardRow > 1)
        //     *prev &= ~FLAG_THISFRAME;
    }


    if (amoebaCounter) {
        if (!amoebaAudio) {
            amoebaAudio = true;
            AddAudio(SFX_AMOEBA);
        }
    }
    else  {
        KillAudio(SFX_AMOEBA);
        amoebaAudio = false;
    }

}




// const char AnimDirt[] = {       // ?
//     CH_DIRT,20,
//     CH_DIRT1,20,
//     CH_DIRT2,20,
//     CH_DIRT3,20,
//     CH_DIRT3,20,
//     255,
// };



void processAnimationCommand() {

    while (playerAnimationCount == 0)
        switch (*playerAnimation) {

        case FRAME_FLIP:
            rockfordDirection = -rockfordDirection;
            playerAnimation++;
            break;

        case FRAME_LOOP:
            if (playerAnimationLoop)
                playerAnimation = playerAnimationLoop;
            else {
                playerAnimation++;            
                playerAnimationLoop = 0;
            }
            break;

        case FRAME_STOP:
            playerAnimationID = -1;
            setAnimation(ID_STAND);
            break;

        case FRAME_ADJUST: {
            frameAdjustX = *++playerAnimation;
            frameAdjustY = *++playerAnimation;
            frameAdjustSmallX = *++playerAnimation;
            frameAdjustSmallY = *++playerAnimation;
            playerAnimation++;
        }
            break;

        default:
            playerAnimationCount = (*(playerAnimation+1)) * DEBUG_SLOWDOWN;
            break;

        }
}


void updateAnimation() {

    if (playerAnimationCount)
        playerAnimationCount--;
    else {
        playerAnimation += 2;
        processAnimationCommand();
        playerAnimationCount--;
    }
}

void setAnimation(int animID) {

    if (playerAnimationID != animID) {
        playerAnimationID = animID;
        playerAnimation = playerAnimationLoop = animIndex[animID];
//        if (playerAnimationLoop < 0)
//            playerAnimationLoop = 0;
        playerAnimationCount = 0;

        processAnimationCommand();

        //frameAdjustX = 0;
        //frameAdjustY = 0;
    }
}



// EOF
